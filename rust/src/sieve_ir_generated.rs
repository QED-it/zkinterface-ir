// automatically generated by the FlatBuffers compiler, do not modify



use std::mem;
use std::cmp::Ordering;

extern crate flatbuffers;
use self::flatbuffers::EndianScalar;

#[allow(unused_imports, dead_code)]
pub mod sieve_ir {

  use std::mem;
  use std::cmp::Ordering;

  extern crate flatbuffers;
  use self::flatbuffers::EndianScalar;

#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum Message {
  NONE = 0,
  Relation = 1,
  Instance = 2,
  Witness = 3,

}

const ENUM_MIN_MESSAGE: u8 = 0;
const ENUM_MAX_MESSAGE: u8 = 3;

impl<'a> flatbuffers::Follow<'a> for Message {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for Message {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const Message;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const Message;
    unsafe { *p }
  }
}

impl flatbuffers::Push for Message {
    type Output = Message;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<Message>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_MESSAGE:[Message; 4] = [
  Message::NONE,
  Message::Relation,
  Message::Instance,
  Message::Witness
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_MESSAGE:[&'static str; 4] = [
    "NONE",
    "Relation",
    "Instance",
    "Witness"
];

pub fn enum_name_message(e: Message) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_MESSAGE[index as usize]
}

pub struct MessageUnionTableOffset {}
#[allow(non_camel_case_types)]
#[repr(u8)]
#[derive(Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Hash, Debug)]
pub enum GateSet {
  NONE = 0,
  GateConstant = 1,
  GateAssertZero = 2,
  GateCopy = 3,
  GateAdd = 4,
  GateMul = 5,
  GateAddConstant = 6,
  GateMulConstant = 7,
  GateAnd = 8,
  GateXor = 9,
  GateNot = 10,
  GateIf = 11,

}

const ENUM_MIN_GATE_SET: u8 = 0;
const ENUM_MAX_GATE_SET: u8 = 11;

impl<'a> flatbuffers::Follow<'a> for GateSet {
  type Inner = Self;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::read_scalar_at::<Self>(buf, loc)
  }
}

impl flatbuffers::EndianScalar for GateSet {
  #[inline]
  fn to_little_endian(self) -> Self {
    let n = u8::to_le(self as u8);
    let p = &n as *const u8 as *const GateSet;
    unsafe { *p }
  }
  #[inline]
  fn from_little_endian(self) -> Self {
    let n = u8::from_le(self as u8);
    let p = &n as *const u8 as *const GateSet;
    unsafe { *p }
  }
}

impl flatbuffers::Push for GateSet {
    type Output = GateSet;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        flatbuffers::emplace_scalar::<GateSet>(dst, *self);
    }
}

#[allow(non_camel_case_types)]
const ENUM_VALUES_GATE_SET:[GateSet; 12] = [
  GateSet::NONE,
  GateSet::GateConstant,
  GateSet::GateAssertZero,
  GateSet::GateCopy,
  GateSet::GateAdd,
  GateSet::GateMul,
  GateSet::GateAddConstant,
  GateSet::GateMulConstant,
  GateSet::GateAnd,
  GateSet::GateXor,
  GateSet::GateNot,
  GateSet::GateIf
];

#[allow(non_camel_case_types)]
const ENUM_NAMES_GATE_SET:[&'static str; 12] = [
    "NONE",
    "GateConstant",
    "GateAssertZero",
    "GateCopy",
    "GateAdd",
    "GateMul",
    "GateAddConstant",
    "GateMulConstant",
    "GateAnd",
    "GateXor",
    "GateNot",
    "GateIf"
];

pub fn enum_name_gate_set(e: GateSet) -> &'static str {
  let index = e as u8;
  ENUM_NAMES_GATE_SET[index as usize]
}

pub struct GateSetUnionTableOffset {}
// struct Wire, aligned to 8
#[repr(C, align(8))]
#[derive(Clone, Copy, Debug, PartialEq)]
pub struct Wire {
  id_: u64,
} // pub struct Wire
impl flatbuffers::SafeSliceAccess for Wire {}
impl<'a> flatbuffers::Follow<'a> for Wire {
  type Inner = &'a Wire;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    <&'a Wire>::follow(buf, loc)
  }
}
impl<'a> flatbuffers::Follow<'a> for &'a Wire {
  type Inner = &'a Wire;
  #[inline]
  fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
    flatbuffers::follow_cast_ref::<Wire>(buf, loc)
  }
}
impl<'b> flatbuffers::Push for Wire {
    type Output = Wire;
    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(self as *const Wire as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}
impl<'b> flatbuffers::Push for &'b Wire {
    type Output = Wire;

    #[inline]
    fn push(&self, dst: &mut [u8], _rest: &[u8]) {
        let src = unsafe {
            ::std::slice::from_raw_parts(*self as *const Wire as *const u8, Self::size())
        };
        dst.copy_from_slice(src);
    }
}


impl Wire {
  pub fn new<'a>(_id: u64) -> Self {
    Wire {
      id_: _id.to_little_endian(),

    }
  }
  pub fn id<'a>(&'a self) -> u64 {
    self.id_.from_little_endian()
  }
}

pub enum HeaderOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Header<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Header<'a> {
    type Inner = Header<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Header<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Header {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args HeaderArgs<'args>) -> flatbuffers::WIPOffset<Header<'bldr>> {
      let mut builder = HeaderBuilder::new(_fbb);
      builder.add_field_degree(args.field_degree);
      if let Some(x) = args.field_characteristic { builder.add_field_characteristic(x); }
      if let Some(x) = args.profile { builder.add_profile(x); }
      if let Some(x) = args.version { builder.add_version(x); }
      builder.finish()
    }

    pub const VT_VERSION: flatbuffers::VOffsetT = 4;
    pub const VT_PROFILE: flatbuffers::VOffsetT = 6;
    pub const VT_FIELD_CHARACTERISTIC: flatbuffers::VOffsetT = 8;
    pub const VT_FIELD_DEGREE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn version(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_VERSION, None)
  }
  #[inline]
  pub fn profile(&self) -> Option<&'a str> {
    self._tab.get::<flatbuffers::ForwardsUOffset<&str>>(Header::VT_PROFILE, None)
  }
  #[inline]
  pub fn field_characteristic(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Header::VT_FIELD_CHARACTERISTIC, None).map(|v| v.safe_slice())
  }
  #[inline]
  pub fn field_degree(&self) -> u32 {
    self._tab.get::<u32>(Header::VT_FIELD_DEGREE, Some(0)).unwrap()
  }
}

pub struct HeaderArgs<'a> {
    pub version: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub profile: Option<flatbuffers::WIPOffset<&'a  str>>,
    pub field_characteristic: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
    pub field_degree: u32,
}
impl<'a> Default for HeaderArgs<'a> {
    #[inline]
    fn default() -> Self {
        HeaderArgs {
            version: None,
            profile: None,
            field_characteristic: None,
            field_degree: 0,
        }
    }
}
pub struct HeaderBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> HeaderBuilder<'a, 'b> {
  #[inline]
  pub fn add_version(&mut self, version: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_VERSION, version);
  }
  #[inline]
  pub fn add_profile(&mut self, profile: flatbuffers::WIPOffset<&'b  str>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_PROFILE, profile);
  }
  #[inline]
  pub fn add_field_characteristic(&mut self, field_characteristic: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Header::VT_FIELD_CHARACTERISTIC, field_characteristic);
  }
  #[inline]
  pub fn add_field_degree(&mut self, field_degree: u32) {
    self.fbb_.push_slot::<u32>(Header::VT_FIELD_DEGREE, field_degree, 0);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> HeaderBuilder<'a, 'b> {
    let start = _fbb.start_table();
    HeaderBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Header<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RelationOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Relation<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Relation<'a> {
    type Inner = Relation<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Relation<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Relation {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RelationArgs<'args>) -> flatbuffers::WIPOffset<Relation<'bldr>> {
      let mut builder = RelationBuilder::new(_fbb);
      builder.add_num_common_inputs(args.num_common_inputs);
      builder.add_num_short_witness(args.num_short_witness);
      builder.add_num_wires(args.num_wires);
      if let Some(x) = args.gates { builder.add_gates(x); }
      if let Some(x) = args.header { builder.add_header(x); }
      builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_NUM_WIRES: flatbuffers::VOffsetT = 6;
    pub const VT_NUM_SHORT_WITNESS: flatbuffers::VOffsetT = 8;
    pub const VT_NUM_COMMON_INPUTS: flatbuffers::VOffsetT = 10;
    pub const VT_GATES: flatbuffers::VOffsetT = 12;

  #[inline]
  pub fn header(&self) -> Option<Header<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Header<'a>>>(Relation::VT_HEADER, None)
  }
  #[inline]
  pub fn num_wires(&self) -> u64 {
    self._tab.get::<u64>(Relation::VT_NUM_WIRES, Some(0)).unwrap()
  }
  #[inline]
  pub fn num_short_witness(&self) -> u64 {
    self._tab.get::<u64>(Relation::VT_NUM_SHORT_WITNESS, Some(0)).unwrap()
  }
  #[inline]
  pub fn num_common_inputs(&self) -> u64 {
    self._tab.get::<u64>(Relation::VT_NUM_COMMON_INPUTS, Some(0)).unwrap()
  }
  #[inline]
  pub fn gates(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Gate<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Gate<'a>>>>>(Relation::VT_GATES, None)
  }
}

pub struct RelationArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<Header<'a >>>,
    pub num_wires: u64,
    pub num_short_witness: u64,
    pub num_common_inputs: u64,
    pub gates: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Gate<'a >>>>>,
}
impl<'a> Default for RelationArgs<'a> {
    #[inline]
    fn default() -> Self {
        RelationArgs {
            header: None,
            num_wires: 0,
            num_short_witness: 0,
            num_common_inputs: 0,
            gates: None,
        }
    }
}
pub struct RelationBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RelationBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<Header<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Header>>(Relation::VT_HEADER, header);
  }
  #[inline]
  pub fn add_num_wires(&mut self, num_wires: u64) {
    self.fbb_.push_slot::<u64>(Relation::VT_NUM_WIRES, num_wires, 0);
  }
  #[inline]
  pub fn add_num_short_witness(&mut self, num_short_witness: u64) {
    self.fbb_.push_slot::<u64>(Relation::VT_NUM_SHORT_WITNESS, num_short_witness, 0);
  }
  #[inline]
  pub fn add_num_common_inputs(&mut self, num_common_inputs: u64) {
    self.fbb_.push_slot::<u64>(Relation::VT_NUM_COMMON_INPUTS, num_common_inputs, 0);
  }
  #[inline]
  pub fn add_gates(&mut self, gates: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Gate<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Relation::VT_GATES, gates);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RelationBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RelationBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Relation<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum InstanceOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Instance<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Instance<'a> {
    type Inner = Instance<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Instance<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Instance {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args InstanceArgs<'args>) -> flatbuffers::WIPOffset<Instance<'bldr>> {
      let mut builder = InstanceBuilder::new(_fbb);
      if let Some(x) = args.common_inputs { builder.add_common_inputs(x); }
      if let Some(x) = args.header { builder.add_header(x); }
      builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_COMMON_INPUTS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn header(&self) -> Option<Header<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Header<'a>>>(Instance::VT_HEADER, None)
  }
  #[inline]
  pub fn common_inputs(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Assignment<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Assignment<'a>>>>>(Instance::VT_COMMON_INPUTS, None)
  }
}

pub struct InstanceArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<Header<'a >>>,
    pub common_inputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Assignment<'a >>>>>,
}
impl<'a> Default for InstanceArgs<'a> {
    #[inline]
    fn default() -> Self {
        InstanceArgs {
            header: None,
            common_inputs: None,
        }
    }
}
pub struct InstanceBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> InstanceBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<Header<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Header>>(Instance::VT_HEADER, header);
  }
  #[inline]
  pub fn add_common_inputs(&mut self, common_inputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Assignment<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Instance::VT_COMMON_INPUTS, common_inputs);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> InstanceBuilder<'a, 'b> {
    let start = _fbb.start_table();
    InstanceBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Instance<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum WitnessOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Witness<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Witness<'a> {
    type Inner = Witness<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Witness<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Witness {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args WitnessArgs<'args>) -> flatbuffers::WIPOffset<Witness<'bldr>> {
      let mut builder = WitnessBuilder::new(_fbb);
      if let Some(x) = args.short_witness { builder.add_short_witness(x); }
      if let Some(x) = args.header { builder.add_header(x); }
      builder.finish()
    }

    pub const VT_HEADER: flatbuffers::VOffsetT = 4;
    pub const VT_SHORT_WITNESS: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn header(&self) -> Option<Header<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<Header<'a>>>(Witness::VT_HEADER, None)
  }
  #[inline]
  pub fn short_witness(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Assignment<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Assignment<'a>>>>>(Witness::VT_SHORT_WITNESS, None)
  }
}

pub struct WitnessArgs<'a> {
    pub header: Option<flatbuffers::WIPOffset<Header<'a >>>,
    pub short_witness: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Assignment<'a >>>>>,
}
impl<'a> Default for WitnessArgs<'a> {
    #[inline]
    fn default() -> Self {
        WitnessArgs {
            header: None,
            short_witness: None,
        }
    }
}
pub struct WitnessBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> WitnessBuilder<'a, 'b> {
  #[inline]
  pub fn add_header(&mut self, header: flatbuffers::WIPOffset<Header<'b >>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<Header>>(Witness::VT_HEADER, header);
  }
  #[inline]
  pub fn add_short_witness(&mut self, short_witness: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Assignment<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Witness::VT_SHORT_WITNESS, short_witness);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> WitnessBuilder<'a, 'b> {
    let start = _fbb.start_table();
    WitnessBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Witness<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum AssignmentOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Assignment<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Assignment<'a> {
    type Inner = Assignment<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Assignment<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Assignment {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args AssignmentArgs<'args>) -> flatbuffers::WIPOffset<Assignment<'bldr>> {
      let mut builder = AssignmentBuilder::new(_fbb);
      if let Some(x) = args.value { builder.add_value(x); }
      if let Some(x) = args.id { builder.add_id(x); }
      builder.finish()
    }

    pub const VT_ID: flatbuffers::VOffsetT = 4;
    pub const VT_VALUE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn id(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(Assignment::VT_ID, None)
  }
  #[inline]
  pub fn value(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(Assignment::VT_VALUE, None).map(|v| v.safe_slice())
  }
}

pub struct AssignmentArgs<'a> {
    pub id: Option<&'a  Wire>,
    pub value: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for AssignmentArgs<'a> {
    #[inline]
    fn default() -> Self {
        AssignmentArgs {
            id: None,
            value: None,
        }
    }
}
pub struct AssignmentBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> AssignmentBuilder<'a, 'b> {
  #[inline]
  pub fn add_id(&mut self, id: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(Assignment::VT_ID, id);
  }
  #[inline]
  pub fn add_value(&mut self, value: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Assignment::VT_VALUE, value);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> AssignmentBuilder<'a, 'b> {
    let start = _fbb.start_table();
    AssignmentBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Assignment<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateConstantOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateConstant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateConstant<'a> {
    type Inner = GateConstant<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateConstant<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateConstant {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateConstantArgs<'args>) -> flatbuffers::WIPOffset<GateConstant<'bldr>> {
      let mut builder = GateConstantBuilder::new(_fbb);
      if let Some(x) = args.constant { builder.add_constant(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_CONSTANT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn output(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateConstant::VT_OUTPUT, None)
  }
  #[inline]
  pub fn constant(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GateConstant::VT_CONSTANT, None).map(|v| v.safe_slice())
  }
}

pub struct GateConstantArgs<'a> {
    pub output: Option<&'a  Wire>,
    pub constant: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for GateConstantArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateConstantArgs {
            output: None,
            constant: None,
        }
    }
}
pub struct GateConstantBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateConstantBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateConstant::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_constant(&mut self, constant: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateConstant::VT_CONSTANT, constant);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateConstantBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateConstantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateConstant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateAssertZeroOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateAssertZero<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAssertZero<'a> {
    type Inner = GateAssertZero<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateAssertZero<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateAssertZero {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateAssertZeroArgs<'args>) -> flatbuffers::WIPOffset<GateAssertZero<'bldr>> {
      let mut builder = GateAssertZeroBuilder::new(_fbb);
      if let Some(x) = args.input { builder.add_input(x); }
      builder.finish()
    }

    pub const VT_INPUT: flatbuffers::VOffsetT = 4;

  #[inline]
  pub fn input(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateAssertZero::VT_INPUT, None)
  }
}

pub struct GateAssertZeroArgs<'a> {
    pub input: Option<&'a  Wire>,
}
impl<'a> Default for GateAssertZeroArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateAssertZeroArgs {
            input: None,
        }
    }
}
pub struct GateAssertZeroBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAssertZeroBuilder<'a, 'b> {
  #[inline]
  pub fn add_input(&mut self, input: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateAssertZero::VT_INPUT, input);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAssertZeroBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAssertZeroBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAssertZero<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateCopyOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateCopy<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateCopy<'a> {
    type Inner = GateCopy<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateCopy<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateCopy {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateCopyArgs<'args>) -> flatbuffers::WIPOffset<GateCopy<'bldr>> {
      let mut builder = GateCopyBuilder::new(_fbb);
      if let Some(x) = args.input { builder.add_input(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_INPUT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn output(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateCopy::VT_OUTPUT, None)
  }
  #[inline]
  pub fn input(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateCopy::VT_INPUT, None)
  }
}

pub struct GateCopyArgs<'a> {
    pub output: Option<&'a  Wire>,
    pub input: Option<&'a  Wire>,
}
impl<'a> Default for GateCopyArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateCopyArgs {
            output: None,
            input: None,
        }
    }
}
pub struct GateCopyBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateCopyBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateCopy::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_input(&mut self, input: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateCopy::VT_INPUT, input);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateCopyBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateCopyBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateCopy<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateAddOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateAdd<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAdd<'a> {
    type Inner = GateAdd<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateAdd<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateAdd {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateAddArgs<'args>) -> flatbuffers::WIPOffset<GateAdd<'bldr>> {
      let mut builder = GateAddBuilder::new(_fbb);
      if let Some(x) = args.right { builder.add_right(x); }
      if let Some(x) = args.left { builder.add_left(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_LEFT: flatbuffers::VOffsetT = 6;
    pub const VT_RIGHT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn output(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateAdd::VT_OUTPUT, None)
  }
  #[inline]
  pub fn left(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateAdd::VT_LEFT, None)
  }
  #[inline]
  pub fn right(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateAdd::VT_RIGHT, None)
  }
}

pub struct GateAddArgs<'a> {
    pub output: Option<&'a  Wire>,
    pub left: Option<&'a  Wire>,
    pub right: Option<&'a  Wire>,
}
impl<'a> Default for GateAddArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateAddArgs {
            output: None,
            left: None,
            right: None,
        }
    }
}
pub struct GateAddBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAddBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateAdd::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_left(&mut self, left: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateAdd::VT_LEFT, left);
  }
  #[inline]
  pub fn add_right(&mut self, right: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateAdd::VT_RIGHT, right);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAddBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAddBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAdd<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateMulOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateMul<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateMul<'a> {
    type Inner = GateMul<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateMul<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateMul {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateMulArgs<'args>) -> flatbuffers::WIPOffset<GateMul<'bldr>> {
      let mut builder = GateMulBuilder::new(_fbb);
      if let Some(x) = args.right { builder.add_right(x); }
      if let Some(x) = args.left { builder.add_left(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_LEFT: flatbuffers::VOffsetT = 6;
    pub const VT_RIGHT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn output(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateMul::VT_OUTPUT, None)
  }
  #[inline]
  pub fn left(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateMul::VT_LEFT, None)
  }
  #[inline]
  pub fn right(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateMul::VT_RIGHT, None)
  }
}

pub struct GateMulArgs<'a> {
    pub output: Option<&'a  Wire>,
    pub left: Option<&'a  Wire>,
    pub right: Option<&'a  Wire>,
}
impl<'a> Default for GateMulArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateMulArgs {
            output: None,
            left: None,
            right: None,
        }
    }
}
pub struct GateMulBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateMulBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateMul::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_left(&mut self, left: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateMul::VT_LEFT, left);
  }
  #[inline]
  pub fn add_right(&mut self, right: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateMul::VT_RIGHT, right);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateMulBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateMulBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateMul<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateAddConstantOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateAddConstant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAddConstant<'a> {
    type Inner = GateAddConstant<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateAddConstant<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateAddConstant {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateAddConstantArgs<'args>) -> flatbuffers::WIPOffset<GateAddConstant<'bldr>> {
      let mut builder = GateAddConstantBuilder::new(_fbb);
      if let Some(x) = args.constant { builder.add_constant(x); }
      if let Some(x) = args.input { builder.add_input(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_INPUT: flatbuffers::VOffsetT = 6;
    pub const VT_CONSTANT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn output(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateAddConstant::VT_OUTPUT, None)
  }
  #[inline]
  pub fn input(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateAddConstant::VT_INPUT, None)
  }
  #[inline]
  pub fn constant(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GateAddConstant::VT_CONSTANT, None).map(|v| v.safe_slice())
  }
}

pub struct GateAddConstantArgs<'a> {
    pub output: Option<&'a  Wire>,
    pub input: Option<&'a  Wire>,
    pub constant: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for GateAddConstantArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateAddConstantArgs {
            output: None,
            input: None,
            constant: None,
        }
    }
}
pub struct GateAddConstantBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAddConstantBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateAddConstant::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_input(&mut self, input: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateAddConstant::VT_INPUT, input);
  }
  #[inline]
  pub fn add_constant(&mut self, constant: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateAddConstant::VT_CONSTANT, constant);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAddConstantBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAddConstantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAddConstant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateMulConstantOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateMulConstant<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateMulConstant<'a> {
    type Inner = GateMulConstant<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateMulConstant<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateMulConstant {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateMulConstantArgs<'args>) -> flatbuffers::WIPOffset<GateMulConstant<'bldr>> {
      let mut builder = GateMulConstantBuilder::new(_fbb);
      if let Some(x) = args.constant { builder.add_constant(x); }
      if let Some(x) = args.input { builder.add_input(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_INPUT: flatbuffers::VOffsetT = 6;
    pub const VT_CONSTANT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn output(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateMulConstant::VT_OUTPUT, None)
  }
  #[inline]
  pub fn input(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateMulConstant::VT_INPUT, None)
  }
  #[inline]
  pub fn constant(&self) -> Option<&'a [u8]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<'a, u8>>>(GateMulConstant::VT_CONSTANT, None).map(|v| v.safe_slice())
  }
}

pub struct GateMulConstantArgs<'a> {
    pub output: Option<&'a  Wire>,
    pub input: Option<&'a  Wire>,
    pub constant: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a ,  u8>>>,
}
impl<'a> Default for GateMulConstantArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateMulConstantArgs {
            output: None,
            input: None,
            constant: None,
        }
    }
}
pub struct GateMulConstantBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateMulConstantBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateMulConstant::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_input(&mut self, input: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateMulConstant::VT_INPUT, input);
  }
  #[inline]
  pub fn add_constant(&mut self, constant: flatbuffers::WIPOffset<flatbuffers::Vector<'b , u8>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateMulConstant::VT_CONSTANT, constant);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateMulConstantBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateMulConstantBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateMulConstant<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateAndOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateAnd<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateAnd<'a> {
    type Inner = GateAnd<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateAnd<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateAnd {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateAndArgs<'args>) -> flatbuffers::WIPOffset<GateAnd<'bldr>> {
      let mut builder = GateAndBuilder::new(_fbb);
      if let Some(x) = args.right { builder.add_right(x); }
      if let Some(x) = args.left { builder.add_left(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_LEFT: flatbuffers::VOffsetT = 6;
    pub const VT_RIGHT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn output(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateAnd::VT_OUTPUT, None)
  }
  #[inline]
  pub fn left(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateAnd::VT_LEFT, None)
  }
  #[inline]
  pub fn right(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateAnd::VT_RIGHT, None)
  }
}

pub struct GateAndArgs<'a> {
    pub output: Option<&'a  Wire>,
    pub left: Option<&'a  Wire>,
    pub right: Option<&'a  Wire>,
}
impl<'a> Default for GateAndArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateAndArgs {
            output: None,
            left: None,
            right: None,
        }
    }
}
pub struct GateAndBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateAndBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateAnd::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_left(&mut self, left: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateAnd::VT_LEFT, left);
  }
  #[inline]
  pub fn add_right(&mut self, right: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateAnd::VT_RIGHT, right);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateAndBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateAndBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateAnd<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateXorOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateXor<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateXor<'a> {
    type Inner = GateXor<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateXor<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateXor {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateXorArgs<'args>) -> flatbuffers::WIPOffset<GateXor<'bldr>> {
      let mut builder = GateXorBuilder::new(_fbb);
      if let Some(x) = args.right { builder.add_right(x); }
      if let Some(x) = args.left { builder.add_left(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_LEFT: flatbuffers::VOffsetT = 6;
    pub const VT_RIGHT: flatbuffers::VOffsetT = 8;

  #[inline]
  pub fn output(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateXor::VT_OUTPUT, None)
  }
  #[inline]
  pub fn left(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateXor::VT_LEFT, None)
  }
  #[inline]
  pub fn right(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateXor::VT_RIGHT, None)
  }
}

pub struct GateXorArgs<'a> {
    pub output: Option<&'a  Wire>,
    pub left: Option<&'a  Wire>,
    pub right: Option<&'a  Wire>,
}
impl<'a> Default for GateXorArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateXorArgs {
            output: None,
            left: None,
            right: None,
        }
    }
}
pub struct GateXorBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateXorBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateXor::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_left(&mut self, left: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateXor::VT_LEFT, left);
  }
  #[inline]
  pub fn add_right(&mut self, right: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateXor::VT_RIGHT, right);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateXorBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateXorBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateXor<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateNotOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateNot<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateNot<'a> {
    type Inner = GateNot<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateNot<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateNot {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateNotArgs<'args>) -> flatbuffers::WIPOffset<GateNot<'bldr>> {
      let mut builder = GateNotBuilder::new(_fbb);
      if let Some(x) = args.input { builder.add_input(x); }
      if let Some(x) = args.output { builder.add_output(x); }
      builder.finish()
    }

    pub const VT_OUTPUT: flatbuffers::VOffsetT = 4;
    pub const VT_INPUT: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn output(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateNot::VT_OUTPUT, None)
  }
  #[inline]
  pub fn input(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateNot::VT_INPUT, None)
  }
}

pub struct GateNotArgs<'a> {
    pub output: Option<&'a  Wire>,
    pub input: Option<&'a  Wire>,
}
impl<'a> Default for GateNotArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateNotArgs {
            output: None,
            input: None,
        }
    }
}
pub struct GateNotBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateNotBuilder<'a, 'b> {
  #[inline]
  pub fn add_output(&mut self, output: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateNot::VT_OUTPUT, output);
  }
  #[inline]
  pub fn add_input(&mut self, input: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateNot::VT_INPUT, input);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateNotBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateNotBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateNot<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateIfOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct GateIf<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for GateIf<'a> {
    type Inner = GateIf<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> GateIf<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        GateIf {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateIfArgs<'args>) -> flatbuffers::WIPOffset<GateIf<'bldr>> {
      let mut builder = GateIfBuilder::new(_fbb);
      if let Some(x) = args.branch_else { builder.add_branch_else(x); }
      if let Some(x) = args.branch_zero { builder.add_branch_zero(x); }
      if let Some(x) = args.outputs { builder.add_outputs(x); }
      if let Some(x) = args.condition { builder.add_condition(x); }
      builder.finish()
    }

    pub const VT_CONDITION: flatbuffers::VOffsetT = 4;
    pub const VT_OUTPUTS: flatbuffers::VOffsetT = 6;
    pub const VT_BRANCH_ZERO: flatbuffers::VOffsetT = 8;
    pub const VT_BRANCH_ELSE: flatbuffers::VOffsetT = 10;

  #[inline]
  pub fn condition(&self) -> Option<&'a Wire> {
    self._tab.get::<Wire>(GateIf::VT_CONDITION, None)
  }
  #[inline]
  pub fn outputs(&self) -> Option<&'a [Wire]> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<Wire>>>(GateIf::VT_OUTPUTS, None).map(|v| v.safe_slice() )
  }
  #[inline]
  pub fn branch_zero(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Gate<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Gate<'a>>>>>(GateIf::VT_BRANCH_ZERO, None)
  }
  #[inline]
  pub fn branch_else(&self) -> Option<flatbuffers::Vector<'a, flatbuffers::ForwardsUOffset<Gate<'a>>>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Vector<flatbuffers::ForwardsUOffset<Gate<'a>>>>>(GateIf::VT_BRANCH_ELSE, None)
  }
}

pub struct GateIfArgs<'a> {
    pub condition: Option<&'a  Wire>,
    pub outputs: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , Wire>>>,
    pub branch_zero: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Gate<'a >>>>>,
    pub branch_else: Option<flatbuffers::WIPOffset<flatbuffers::Vector<'a , flatbuffers::ForwardsUOffset<Gate<'a >>>>>,
}
impl<'a> Default for GateIfArgs<'a> {
    #[inline]
    fn default() -> Self {
        GateIfArgs {
            condition: None,
            outputs: None,
            branch_zero: None,
            branch_else: None,
        }
    }
}
pub struct GateIfBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateIfBuilder<'a, 'b> {
  #[inline]
  pub fn add_condition(&mut self, condition: &'b  Wire) {
    self.fbb_.push_slot_always::<&Wire>(GateIf::VT_CONDITION, condition);
  }
  #[inline]
  pub fn add_outputs(&mut self, outputs: flatbuffers::WIPOffset<flatbuffers::Vector<'b , Wire>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateIf::VT_OUTPUTS, outputs);
  }
  #[inline]
  pub fn add_branch_zero(&mut self, branch_zero: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Gate<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateIf::VT_BRANCH_ZERO, branch_zero);
  }
  #[inline]
  pub fn add_branch_else(&mut self, branch_else: flatbuffers::WIPOffset<flatbuffers::Vector<'b , flatbuffers::ForwardsUOffset<Gate<'b >>>>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(GateIf::VT_BRANCH_ELSE, branch_else);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateIfBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateIfBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<GateIf<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum GateOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Gate<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Gate<'a> {
    type Inner = Gate<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Gate<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Gate {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args GateArgs) -> flatbuffers::WIPOffset<Gate<'bldr>> {
      let mut builder = GateBuilder::new(_fbb);
      if let Some(x) = args.gate { builder.add_gate(x); }
      builder.add_gate_type(args.gate_type);
      builder.finish()
    }

    pub const VT_GATE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_GATE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn gate_type(&self) -> GateSet {
    self._tab.get::<GateSet>(Gate::VT_GATE_TYPE, Some(GateSet::NONE)).unwrap()
  }
  #[inline]
  pub fn gate(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Gate::VT_GATE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_constant(&self) -> Option<GateConstant<'a>> {
    if self.gate_type() == GateSet::GateConstant {
      self.gate().map(|u| GateConstant::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_assert_zero(&self) -> Option<GateAssertZero<'a>> {
    if self.gate_type() == GateSet::GateAssertZero {
      self.gate().map(|u| GateAssertZero::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_copy(&self) -> Option<GateCopy<'a>> {
    if self.gate_type() == GateSet::GateCopy {
      self.gate().map(|u| GateCopy::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_add(&self) -> Option<GateAdd<'a>> {
    if self.gate_type() == GateSet::GateAdd {
      self.gate().map(|u| GateAdd::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_mul(&self) -> Option<GateMul<'a>> {
    if self.gate_type() == GateSet::GateMul {
      self.gate().map(|u| GateMul::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_add_constant(&self) -> Option<GateAddConstant<'a>> {
    if self.gate_type() == GateSet::GateAddConstant {
      self.gate().map(|u| GateAddConstant::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_mul_constant(&self) -> Option<GateMulConstant<'a>> {
    if self.gate_type() == GateSet::GateMulConstant {
      self.gate().map(|u| GateMulConstant::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_and(&self) -> Option<GateAnd<'a>> {
    if self.gate_type() == GateSet::GateAnd {
      self.gate().map(|u| GateAnd::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_xor(&self) -> Option<GateXor<'a>> {
    if self.gate_type() == GateSet::GateXor {
      self.gate().map(|u| GateXor::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_not(&self) -> Option<GateNot<'a>> {
    if self.gate_type() == GateSet::GateNot {
      self.gate().map(|u| GateNot::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn gate_as_gate_if(&self) -> Option<GateIf<'a>> {
    if self.gate_type() == GateSet::GateIf {
      self.gate().map(|u| GateIf::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct GateArgs {
    pub gate_type: GateSet,
    pub gate: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for GateArgs {
    #[inline]
    fn default() -> Self {
        GateArgs {
            gate_type: GateSet::NONE,
            gate: None,
        }
    }
}
pub struct GateBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> GateBuilder<'a, 'b> {
  #[inline]
  pub fn add_gate_type(&mut self, gate_type: GateSet) {
    self.fbb_.push_slot::<GateSet>(Gate::VT_GATE_TYPE, gate_type, GateSet::NONE);
  }
  #[inline]
  pub fn add_gate(&mut self, gate: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Gate::VT_GATE, gate);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> GateBuilder<'a, 'b> {
    let start = _fbb.start_table();
    GateBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Gate<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

pub enum RootOffset {}
#[derive(Copy, Clone, Debug, PartialEq)]

pub struct Root<'a> {
  pub _tab: flatbuffers::Table<'a>,
}

impl<'a> flatbuffers::Follow<'a> for Root<'a> {
    type Inner = Root<'a>;
    #[inline]
    fn follow(buf: &'a [u8], loc: usize) -> Self::Inner {
        Self {
            _tab: flatbuffers::Table { buf: buf, loc: loc },
        }
    }
}

impl<'a> Root<'a> {
    #[inline]
    pub fn init_from_table(table: flatbuffers::Table<'a>) -> Self {
        Root {
            _tab: table,
        }
    }
    #[allow(unused_mut)]
    pub fn create<'bldr: 'args, 'args: 'mut_bldr, 'mut_bldr>(
        _fbb: &'mut_bldr mut flatbuffers::FlatBufferBuilder<'bldr>,
        args: &'args RootArgs) -> flatbuffers::WIPOffset<Root<'bldr>> {
      let mut builder = RootBuilder::new(_fbb);
      if let Some(x) = args.message { builder.add_message(x); }
      builder.add_message_type(args.message_type);
      builder.finish()
    }

    pub const VT_MESSAGE_TYPE: flatbuffers::VOffsetT = 4;
    pub const VT_MESSAGE: flatbuffers::VOffsetT = 6;

  #[inline]
  pub fn message_type(&self) -> Message {
    self._tab.get::<Message>(Root::VT_MESSAGE_TYPE, Some(Message::NONE)).unwrap()
  }
  #[inline]
  pub fn message(&self) -> Option<flatbuffers::Table<'a>> {
    self._tab.get::<flatbuffers::ForwardsUOffset<flatbuffers::Table<'a>>>(Root::VT_MESSAGE, None)
  }
  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_relation(&self) -> Option<Relation<'a>> {
    if self.message_type() == Message::Relation {
      self.message().map(|u| Relation::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_instance(&self) -> Option<Instance<'a>> {
    if self.message_type() == Message::Instance {
      self.message().map(|u| Instance::init_from_table(u))
    } else {
      None
    }
  }

  #[inline]
  #[allow(non_snake_case)]
  pub fn message_as_witness(&self) -> Option<Witness<'a>> {
    if self.message_type() == Message::Witness {
      self.message().map(|u| Witness::init_from_table(u))
    } else {
      None
    }
  }

}

pub struct RootArgs {
    pub message_type: Message,
    pub message: Option<flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>>,
}
impl<'a> Default for RootArgs {
    #[inline]
    fn default() -> Self {
        RootArgs {
            message_type: Message::NONE,
            message: None,
        }
    }
}
pub struct RootBuilder<'a: 'b, 'b> {
  fbb_: &'b mut flatbuffers::FlatBufferBuilder<'a>,
  start_: flatbuffers::WIPOffset<flatbuffers::TableUnfinishedWIPOffset>,
}
impl<'a: 'b, 'b> RootBuilder<'a, 'b> {
  #[inline]
  pub fn add_message_type(&mut self, message_type: Message) {
    self.fbb_.push_slot::<Message>(Root::VT_MESSAGE_TYPE, message_type, Message::NONE);
  }
  #[inline]
  pub fn add_message(&mut self, message: flatbuffers::WIPOffset<flatbuffers::UnionWIPOffset>) {
    self.fbb_.push_slot_always::<flatbuffers::WIPOffset<_>>(Root::VT_MESSAGE, message);
  }
  #[inline]
  pub fn new(_fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>) -> RootBuilder<'a, 'b> {
    let start = _fbb.start_table();
    RootBuilder {
      fbb_: _fbb,
      start_: start,
    }
  }
  #[inline]
  pub fn finish(self) -> flatbuffers::WIPOffset<Root<'a>> {
    let o = self.fbb_.end_table(self.start_);
    flatbuffers::WIPOffset::new(o.value())
  }
}

#[inline]
pub fn get_root_as_root<'a>(buf: &'a [u8]) -> Root<'a> {
  flatbuffers::get_root::<Root<'a>>(buf)
}

#[inline]
pub fn get_size_prefixed_root_as_root<'a>(buf: &'a [u8]) -> Root<'a> {
  flatbuffers::get_size_prefixed_root::<Root<'a>>(buf)
}

pub const ROOT_IDENTIFIER: &'static str = "siev";

#[inline]
pub fn root_buffer_has_identifier(buf: &[u8]) -> bool {
  return flatbuffers::buffer_has_identifier(buf, ROOT_IDENTIFIER, false);
}

#[inline]
pub fn root_size_prefixed_buffer_has_identifier(buf: &[u8]) -> bool {
  return flatbuffers::buffer_has_identifier(buf, ROOT_IDENTIFIER, true);
}

pub const ROOT_EXTENSION: &'static str = "sieve";

#[inline]
pub fn finish_root_buffer<'a, 'b>(
    fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>,
    root: flatbuffers::WIPOffset<Root<'a>>) {
  fbb.finish(root, Some(ROOT_IDENTIFIER));
}

#[inline]
pub fn finish_size_prefixed_root_buffer<'a, 'b>(fbb: &'b mut flatbuffers::FlatBufferBuilder<'a>, root: flatbuffers::WIPOffset<Root<'a>>) {
  fbb.finish_size_prefixed(root, Some(ROOT_IDENTIFIER));
}
}  // pub mod sieve_ir

